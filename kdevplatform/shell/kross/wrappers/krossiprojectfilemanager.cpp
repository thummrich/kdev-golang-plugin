//This is file has been generated by xmltokross, you should not edit this file but the files used to generate it.

#include <QtCore/QObject>
#include <QtCore/QVariant>
#include <kross/core/manager.h>
#include <kross/core/wrapperinterface.h>
#include <project/interfaces/iprojectfilemanager.h>

class KrossKDevelopIProjectFileManager : public QObject, public Kross::WrapperInterface
{
	Q_OBJECT
	Q_ENUMS(Feature)
	Q_FLAGS(Feature None Folders Targets Files)

	public:
		enum KrossFeature { None=KDevelop::IProjectFileManager::None, Folders=KDevelop::IProjectFileManager::Folders, Targets=KDevelop::IProjectFileManager::Targets, Files=KDevelop::IProjectFileManager::Files };
		KrossKDevelopIProjectFileManager(KDevelop::IProjectFileManager* obj, QObject* parent=0) : QObject(parent), wrapped(obj)		{ setObjectName("KDevelop::IProjectFileManager"); }
		void* wrappedObject() const { return wrapped; }

		Q_SCRIPTABLE KDevelop::IProjectFileManager::Features features() const { return wrapped->features(); }
		Q_SCRIPTABLE QList< KDevelop::ProjectFolderItem* > parse(KDevelop::ProjectFolderItem* x0) { return wrapped->parse(x0); }
		Q_SCRIPTABLE KDevelop::ProjectFolderItem* import(KDevelop::IProject* x0) { return wrapped->import(x0); }
		Q_SCRIPTABLE KJob* createImportJob(KDevelop::ProjectFolderItem* x0) { return wrapped->createImportJob(x0); }
		Q_SCRIPTABLE KDevelop::ProjectFolderItem* addFolder(const KUrl& x0, KDevelop::ProjectFolderItem* x1) { return wrapped->addFolder(x0, x1); }
		Q_SCRIPTABLE KDevelop::ProjectFileItem* addFile(const KUrl& x0, KDevelop::ProjectFolderItem* x1) { return wrapped->addFile(x0, x1); }
		Q_SCRIPTABLE bool removeFolder(KDevelop::ProjectFolderItem* x0) { return wrapped->removeFolder(x0); }
		Q_SCRIPTABLE bool removeFile(KDevelop::ProjectFileItem* x0) { return wrapped->removeFile(x0); }
		Q_SCRIPTABLE bool renameFile(KDevelop::ProjectFileItem* x0, const KUrl& x1) { return wrapped->renameFile(x0, x1); }
		Q_SCRIPTABLE bool renameFolder(KDevelop::ProjectFolderItem* x0, const KUrl& x1) { return wrapped->renameFolder(x0, x1); }
		Q_SCRIPTABLE bool reload(KDevelop::ProjectFolderItem* x0) { return wrapped->reload(x0); }
	private:
		KDevelop::IProjectFileManager* wrapped;
};

bool krossiprojectfilemanager_registerHandler(const QByteArray& name, Kross::MetaTypeHandler::FunctionPtr* handler)
{ Kross::Manager::self().registerMetaTypeHandler(name, handler); return false; }

namespace Handlers
{
QVariant _kDevelopIProjectFileManagerHandler(void* type)
{
	if(!type) return QVariant();
	KDevelop::IProjectFileManager* t=static_cast<KDevelop::IProjectFileManager*>(type);
	Q_ASSERT(dynamic_cast<KDevelop::IProjectFileManager*>(t));
	return qVariantFromValue((QObject*) new KrossKDevelopIProjectFileManager(t, 0));
}
bool b_KDevelopIProjectFileManager1=krossiprojectfilemanager_registerHandler("IProjectFileManager*", _kDevelopIProjectFileManagerHandler);
bool b_KDevelopIProjectFileManager=krossiprojectfilemanager_registerHandler("KDevelop::IProjectFileManager*", _kDevelopIProjectFileManagerHandler);
QVariant kDevelopIProjectFileManagerHandler(KDevelop::IProjectFileManager* type){ return _kDevelopIProjectFileManagerHandler(type); }
QVariant kDevelopIProjectFileManagerHandler(const KDevelop::IProjectFileManager* type) { return _kDevelopIProjectFileManagerHandler((void*) type); }

}
#include "krossiprojectfilemanager.moc"

//This is file has been generated by xmltokross, you should not edit this file but the files used to generate it.

#include <QtCore/QObject>
#include <QtCore/QVariant>
#include <kross/core/manager.h>
#include <kross/core/wrapperinterface.h>
#include <interfaces/idocument.h>

class KrossKDevelopIDocument : public QObject, public Kross::WrapperInterface
{
	Q_OBJECT
	Q_ENUMS(DocumentState)
	Q_FLAGS(DocumentState Clean Modified Dirty DirtyAndModified)

	Q_ENUMS(DocumentSaveMode)
	Q_FLAGS(DocumentSaveMode Default Silent Discard)

	public:
		enum KrossDocumentState { Clean=KDevelop::IDocument::Clean, Modified=KDevelop::IDocument::Modified, Dirty=KDevelop::IDocument::Dirty, DirtyAndModified=KDevelop::IDocument::DirtyAndModified };
		enum KrossDocumentSaveMode { Default=KDevelop::IDocument::Default, Silent=KDevelop::IDocument::Silent, Discard=KDevelop::IDocument::Discard };
		KrossKDevelopIDocument(KDevelop::IDocument* obj, QObject* parent=0) : QObject(parent), wrapped(obj)		{ setObjectName("KDevelop::IDocument"); }
		void* wrappedObject() const { return wrapped; }

		Q_SCRIPTABLE KUrl url() const { return wrapped->url(); }
		Q_SCRIPTABLE KMimeType::Ptr mimeType() const { return wrapped->mimeType(); }
		Q_SCRIPTABLE KParts::Part* partForView(QWidget* x0) const { return wrapped->partForView(x0); }
		Q_SCRIPTABLE bool isTextDocument() const { return wrapped->isTextDocument(); }
		Q_SCRIPTABLE KTextEditor::Document* textDocument() const { return wrapped->textDocument(); }
		Q_SCRIPTABLE bool save(KDevelop::IDocument::DocumentSaveMode x0=KDevelop::IDocument::Default) { return wrapped->save(x0); }
		Q_SCRIPTABLE void reload() { wrapped->reload(); }
		Q_SCRIPTABLE bool close(KDevelop::IDocument::DocumentSaveMode x0=KDevelop::IDocument::Default) { return wrapped->close(x0); }
		Q_SCRIPTABLE bool isActive() const { return wrapped->isActive(); }
		Q_SCRIPTABLE KDevelop::IDocument::DocumentState state() const { return wrapped->state(); }
		Q_SCRIPTABLE KTextEditor::Cursor cursorPosition() const { return wrapped->cursorPosition(); }
		Q_SCRIPTABLE void setCursorPosition(const KTextEditor::Cursor& x0) { wrapped->setCursorPosition(x0); }
		Q_SCRIPTABLE KTextEditor::Range textSelection() const { return wrapped->textSelection(); }
		Q_SCRIPTABLE void setTextSelection(const KTextEditor::Range& x0) { wrapped->setTextSelection(x0); }
		Q_SCRIPTABLE QString textLine() const { return wrapped->textLine(); }
		Q_SCRIPTABLE QString textWord() const { return wrapped->textWord(); }
		Q_SCRIPTABLE void activate(Sublime::View* x0, KParts::MainWindow* x1) { wrapped->activate(x0, x1); }
	private:
		KDevelop::IDocument* wrapped;
};

bool krossidocument_registerHandler(const QByteArray& name, Kross::MetaTypeHandler::FunctionPtr* handler)
{ Kross::Manager::self().registerMetaTypeHandler(name, handler); return false; }

namespace Handlers
{
QVariant _kDevelopIDocumentHandler(void* type)
{
	if(!type) return QVariant();
	KDevelop::IDocument* t=static_cast<KDevelop::IDocument*>(type);
	Q_ASSERT(dynamic_cast<KDevelop::IDocument*>(t));
	return qVariantFromValue((QObject*) new KrossKDevelopIDocument(t, 0));
}
bool b_KDevelopIDocument1=krossidocument_registerHandler("IDocument*", _kDevelopIDocumentHandler);
bool b_KDevelopIDocument=krossidocument_registerHandler("KDevelop::IDocument*", _kDevelopIDocumentHandler);
QVariant kDevelopIDocumentHandler(KDevelop::IDocument* type){ return _kDevelopIDocumentHandler(type); }
QVariant kDevelopIDocumentHandler(const KDevelop::IDocument* type) { return _kDevelopIDocumentHandler((void*) type); }

}
#include "krossidocument.moc"

//This is file has been generated by xmltokross, you should not edit this file but the files used to generate it.

#include <QtCore/QObject>
#include <QtCore/QVariant>
#include <kross/core/manager.h>
#include <kross/core/wrapperinterface.h>
#include <language/duchain/declaration.h>
#include <language/duchain/declarationid.h>
#include <language/duchain/types/indexedtype.h>
#include <language/duchain/topducontext.h>

class KrossKDevelopDeclaration : public QObject, public Kross::WrapperInterface
{
	Q_OBJECT
	Q_ENUMS(AccessPolicy)
	Q_FLAGS(AccessPolicy Public Protected Private DefaultAccess)

	Q_ENUMS(Kind)
	Q_FLAGS(Kind Type Instance NamespaceAlias Alias Namespace Import)

	public:
		enum KrossAccessPolicy { Public=KDevelop::Declaration::Public, Protected=KDevelop::Declaration::Protected, Private=KDevelop::Declaration::Private, DefaultAccess=KDevelop::Declaration::DefaultAccess };
		enum KrossKind { Type=KDevelop::Declaration::Type, Instance=KDevelop::Declaration::Instance, NamespaceAlias=KDevelop::Declaration::NamespaceAlias, Alias=KDevelop::Declaration::Alias, Namespace=KDevelop::Declaration::Namespace, Import=KDevelop::Declaration::Import };
		KrossKDevelopDeclaration(KDevelop::Declaration* obj, QObject* parent=0) : QObject(parent), wrapped(obj)		{ setObjectName("KDevelop::Declaration"); }
		void* wrappedObject() const { return wrapped; }

		Q_SCRIPTABLE KDevelop::TopDUContext* topContext() const { return wrapped->topContext(); }
		Q_SCRIPTABLE bool isForwardDeclaration() const { return wrapped->isForwardDeclaration(); }
		Q_SCRIPTABLE KDevelop::ForwardDeclaration* toForwardDeclaration() { return wrapped->toForwardDeclaration(); }
		Q_SCRIPTABLE const KDevelop::ForwardDeclaration* toForwardDeclaration() const { return wrapped->toForwardDeclaration(); }
		Q_SCRIPTABLE bool isFunctionDeclaration() const { return wrapped->isFunctionDeclaration(); }
		Q_SCRIPTABLE bool inDUChain() const { return wrapped->inDUChain(); }
		Q_SCRIPTABLE bool isDefinition() const { return wrapped->isDefinition(); }
		Q_SCRIPTABLE void setDeclarationIsDefinition(bool x0) { wrapped->setDeclarationIsDefinition(x0); }
		Q_SCRIPTABLE bool isTypeAlias() const { return wrapped->isTypeAlias(); }
		Q_SCRIPTABLE void setIsTypeAlias(bool x0) { wrapped->setIsTypeAlias(x0); }
		Q_SCRIPTABLE bool isFinal() const { return wrapped->isFinal(); }
		Q_SCRIPTABLE void setFinal(bool x0) { wrapped->setFinal(x0); }
		Q_SCRIPTABLE KDevelop::Declaration* specialize(KDevelop::IndexedInstantiationInformation x0, const KDevelop::TopDUContext* x1, int x2=0) { return wrapped->specialize(x0, x1, x2); }
		Q_SCRIPTABLE KDevelop::DUContext* internalContext() const { return wrapped->internalContext(); }
		Q_SCRIPTABLE void setInternalContext(KDevelop::DUContext* x0) { wrapped->setInternalContext(x0); }
		Q_SCRIPTABLE KDevelop::DUContext* logicalInternalContext(const KDevelop::TopDUContext* x0) const { return wrapped->logicalInternalContext(x0); }
		Q_SCRIPTABLE const KDevelop::Declaration* logicalDeclaration(const KDevelop::TopDUContext* x0) const { return wrapped->logicalDeclaration(x0); }
		Q_SCRIPTABLE KDevelop::Declaration* logicalDeclaration(const KDevelop::TopDUContext* x0) { return wrapped->logicalDeclaration(x0); }
		Q_SCRIPTABLE KDevelop::DUContext* context() const { return wrapped->context(); }
		Q_SCRIPTABLE void setContext(KDevelop::DUContext* x0, bool x1=false) { wrapped->setContext(x0, x1); }
		Q_SCRIPTABLE KDevelop::AbstractType::Ptr abstractType() const { return wrapped->abstractType(); }
		Q_SCRIPTABLE void setAbstractType(KDevelop::AbstractType::Ptr x0) { wrapped->setAbstractType(x0); }
		Q_SCRIPTABLE KDevelop::IndexedType indexedType() const { return wrapped->indexedType(); }
		Q_SCRIPTABLE void setIdentifier(const KDevelop::Identifier& x0) { wrapped->setIdentifier(x0); }
		Q_SCRIPTABLE KDevelop::Identifier identifier() const { return wrapped->identifier(); }
		Q_SCRIPTABLE KDevelop::IndexedIdentifier indexedIdentifier() const { return wrapped->indexedIdentifier(); }
		Q_SCRIPTABLE KDevelop::QualifiedIdentifier qualifiedIdentifier() const { return wrapped->qualifiedIdentifier(); }
		Q_SCRIPTABLE bool equalQualifiedIdentifier(const KDevelop::Declaration* x0) const { return wrapped->equalQualifiedIdentifier(x0); }
		Q_SCRIPTABLE KDevelop::Declaration::Kind kind() const { return wrapped->kind(); }
		Q_SCRIPTABLE void setKind(KDevelop::Declaration::Kind x0) { wrapped->setKind(x0); }
		Q_SCRIPTABLE QByteArray comment() const { return wrapped->comment(); }
		Q_SCRIPTABLE void setComment(const QByteArray& x0) { wrapped->setComment(x0); }
		Q_SCRIPTABLE void setComment(const QString& x0) { wrapped->setComment(x0); }
		Q_SCRIPTABLE bool inSymbolTable() const { return wrapped->inSymbolTable(); }
		Q_SCRIPTABLE void setInSymbolTable(bool x0) { wrapped->setInSymbolTable(x0); }
		Q_SCRIPTABLE bool operator==(const KDevelop::Declaration& x0) const { return wrapped->operator==(x0); }
		Q_SCRIPTABLE QString toString() const { return wrapped->toString(); }
		Q_SCRIPTABLE QMap< KDevelop::IndexedString, QList< KDevelop::SimpleRange > > uses() const { return wrapped->uses(); }
		Q_SCRIPTABLE QList< KTextEditor::SmartRange* > smartUses() const { return wrapped->smartUses(); }
		Q_SCRIPTABLE uint additionalIdentity() const { return wrapped->additionalIdentity(); }
		Q_SCRIPTABLE KDevelop::IndexedInstantiationInformation specialization() const { return wrapped->specialization(); }
		Q_SCRIPTABLE KDevelop::DeclarationId id(bool x0=false) const { return wrapped->id(x0); }
		Q_SCRIPTABLE uint ownIndex() const { return wrapped->ownIndex(); }
		Q_SCRIPTABLE bool isAnonymous() const { return wrapped->isAnonymous(); }
		Q_SCRIPTABLE void clearOwnIndex() { wrapped->clearOwnIndex(); }
		Q_SCRIPTABLE void allocateOwnIndex() { wrapped->allocateOwnIndex(); }
		Q_SCRIPTABLE KDevelop::Declaration* clone() const { return wrapped->clone(); }
		Q_SCRIPTABLE void activateSpecialization() { wrapped->activateSpecialization(); }
	private:
		KDevelop::Declaration* wrapped;
};

bool krossdeclaration_registerHandler(const QByteArray& name, Kross::MetaTypeHandler::FunctionPtr* handler)
{ Kross::Manager::self().registerMetaTypeHandler(name, handler); return false; }

namespace Handlers
{
QVariant _kDevelopDeclarationHandler(void* type)
{
	if(!type) return QVariant();
	KDevelop::Declaration* t=static_cast<KDevelop::Declaration*>(type);
	Q_ASSERT(dynamic_cast<KDevelop::Declaration*>(t));
	return qVariantFromValue((QObject*) new KrossKDevelopDeclaration(t, 0));
}
bool b_KDevelopDeclaration1=krossdeclaration_registerHandler("Declaration*", _kDevelopDeclarationHandler);
bool b_KDevelopDeclaration=krossdeclaration_registerHandler("KDevelop::Declaration*", _kDevelopDeclarationHandler);
QVariant kDevelopDeclarationHandler(KDevelop::Declaration* type){ return _kDevelopDeclarationHandler(type); }
QVariant kDevelopDeclarationHandler(const KDevelop::Declaration* type) { return _kDevelopDeclarationHandler((void*) type); }

}
#include "krossdeclaration.moc"
